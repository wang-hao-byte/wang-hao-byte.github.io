---
title: "进程间通信方式"
published: 2025-08-19
description: "详解进程间的通信方式，包括管道、命名管道、共享内存等"
tags: [系统编程]
category: "操作系统"
draft: false 
lang: "zh-CN"
---
## 1.管道

<p align="center">
    <img src="https://raw.githubusercontent.com/wang-hao-byte/FigureBed/master/202508132331433.png" alt="管道通信示意图">
</p>
- **原理**：一种半双工(可双向传输数据，但不能同时发送)的信道，由内核维护缓冲区。

- **特点**：
  - 只能在亲缘进程(父子、兄弟进程)之间使用。
  - 数据流式传输，读写需要“先写后读”
  - 管道满时写操作阻塞、空时读操作阻塞
- **适用场景**：父子进程通信(如命令行:ls | grep ""audio)
- **示例**

```c++
#include <iostream>
#include <unistd.h>
#include <sys/wait.h>
#include <cstring>
// 模拟音频数据结构
struct AudioData {
    int sampleRate;    // 采样率
    int bitDepth;      // 位深度
    int channelCount;  // 声道数
    char data[1024];   // 音频数据
};
int main() {
    int pipefd[2];
    int ret = pipe(pipefd);
    if (ret == -1) {
        std::cerr << "创建管道失败" << std::endl;
        return 1;
    }
    pid_t pid = fork();
    if (pid == -1) {
        std::cerr << "创建进程失败" << std::endl;
        return 1;
    }
    if (pid == 0) {  // 子进程 - 接收音频数据
        close(pipefd[1]);  // 关闭写端
        AudioData receivedData;
        ssize_t bytesRead = read(pipefd[0], &receivedData, sizeof(AudioData));
        if (bytesRead > 0) {
            std::cout << "子进程收到音频数据:" << std::endl;
            std::cout << "采样率: " << receivedData.sampleRate << "Hz" << std::endl;
            std::cout << "位深度: " << receivedData.bitDepth << "位" << std::endl;
            std::cout << "声道数: " << receivedData.channelCount << std::endl;
            std::cout << "数据片段: " << receivedData.data << std::endl;
        }
        close(pipefd[0]);  // 关闭读端
        return 0;
    } else {  // 父进程 - 发送音频数据
        close(pipefd[0]);  // 关闭读端
        AudioData audioData;
        audioData.sampleRate = 44100;
        audioData.bitDepth = 16;
        audioData.channelCount = 2;
        strcpy(audioData.data, "模拟的PCM音频数据...");
        
        write(pipefd[1], &audioData, sizeof(AudioData));
        std::cout << "父进程发送了音频数据" << std::endl;
        
        close(pipefd[1]);  // 关闭写端
        wait(NULL);        // 等待子进程结束
        return 0;
    }
}
```

## 2.命名管道

![](https://raw.githubusercontent.com/wang-hao-byte/FigureBed/master/202508140044788.png)

- **原理**：原理与管道类似，但通过**文件系统中的特殊文件**(FIFO)标识，不依赖进程亲缘关系。
- **特点**
  - 允许任意进程通信
  - 半双工，需显式创建和删除(mkfifo(),或者系统调用)。
  - 数据在内存中传输，FIFO作为标识，不存储数据
  - 默认阻塞
- **适用场景**：同一主机无亲缘关系的进程
- **示例**

```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>

// FIFO文件路径
#define FIFO_PATH "/tmp/my_fifo"
// 创建FIFO文件
void create_fifo() {
    // 检查FIFO是否已存在
    struct stat st;
    if (stat(FIFO_PATH, &st) == 0) {
        // 如果存在且是FIFO文件，则不需要重新创建
        if (S_ISFIFO(st.st_mode)) {
            printf("FIFO已存在\n");
            return;
        } else {
            // 如果存在但不是FIFO文件，删除它
            unlink(FIFO_PATH);
        }
    }
    // 创建FIFO
    if (mkfifo(FIFO_PATH, 0666) == -1) {
        perror("创建FIFO失败");
        exit(EXIT_FAILURE);
    }
    printf("FIFO创建成功: %s\n", FIFO_PATH);
}
// 写进程：向FIFO发送数据
void writer_process() {
    // 以只写方式打开FIFO
    int fd = open(FIFO_PATH, O_WRONLY);
    if (fd == -1) {
        perror("写进程打开FIFO失败");
        exit(EXIT_FAILURE);
    }
    printf("写进程已启动，输入消息发送（输入'quit'结束）:\n");
    char buffer[1024];
    while (1) {
        // 读取用户输入
        if (fgets(buffer, sizeof(buffer), stdin) == NULL) {
            perror("读取输入失败");
            break;
        }
        // 移除换行符
        buffer[strcspn(buffer, "\n")] = '\0'; 
        // 向FIFO写入数据
        if (write(fd, buffer, strlen(buffer) + 1) == -1) {
            perror("写入FIFO失败");
            break;
        }
        // 检查是否退出
        if (strcmp(buffer, "quit") == 0) {
            printf("写进程退出\n");
            break;
        }
    }
    close(fd);
}
// 读进程：从FIFO接收数据
void reader_process() {
    // 以只读方式打开FIFO
    int fd = open(FIFO_PATH, O_RDONLY);
    if (fd == -1) {
        perror("读进程打开FIFO失败");
        exit(EXIT_FAILURE);
    }
    
    printf("读进程已启动，等待接收消息...\n");
    
    char buffer[1024];
    while (1) {
        // 从FIFO读取数据
        ssize_t bytes_read = read(fd, buffer, sizeof(buffer));
        if (bytes_read == -1) {
            perror("读取FIFO失败");
            break;
        }
        // 检查是否收到退出信号
        if (strcmp(buffer, "quit") == 0) {
            printf("收到退出信号，读进程退出\n");
            break;
        }
        
        printf("收到消息: %s\n", buffer);
    }
    
    close(fd);
}
int main(int argc, char *argv[]) {
    // 检查命令行参数
    if (argc != 2) {
        fprintf(stderr, "用法: %s [create|read|write]\n", argv[0]);
        fprintf(stderr, "  create - 创建FIFO文件\n");
        fprintf(stderr, "  read   - 启动读进程\n");
        fprintf(stderr, "  write  - 启动写进程\n");
        exit(EXIT_FAILURE);
    }
    // 根据参数执行不同功能
    if (strcmp(argv[1], "create") == 0) {
        create_fifo();
    } else if (strcmp(argv[1], "read") == 0) {
        reader_process();
    } else if (strcmp(argv[1], "write") == 0) {
        writer_process();
    } else {
        fprintf(stderr, "无效参数: %s\n", argv[1]);
        exit(EXIT_FAILURE);
    }
    return 0;
}
```

## 3.共享内存

![](https://raw.githubusercontent.com/wang-hao-byte/FigureBed/master/202508190008744.png)

- 原理：
  - 创建一个内核管理的共享内存区域，直接读写内存进行进程通信

- 特点
  - 速度最快的IPC方式(数据无需在进程间通信)
  - 需要配合同步机制(如信号量)防止并发读写冲突。
  - 共享内存自身没有安全机制吗，需要程序员控制。
- 适用场景：高频、大容量数据交换的场景。
- 示例

```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <sys/wait.h>
#include <time.h>
// 共享内存中每个数据块的大小
#define BLOCK_SIZE 128
// 共享内存中数据块的数量
#define BLOCK_COUNT 5
// 共享内存总大小 = 块数量 × 块大小
#define SHM_SIZE (BLOCK_SIZE * BLOCK_COUNT)
// 信号量索引
#define SEM_EMPTY 0  // 空块数量信号量
#define SEM_FULL  1  // 满块数量信号量
#define SEM_MUTEX 2  // 互斥信号量
#define SEM_COUNT 3  // 信号量总数
// 信号量操作函数
void sem_op(int semid, int sem_num, int op) {
    struct sembuf sb;
    sb.sem_num = sem_num;
    sb.sem_op = op;
    sb.sem_flg = 0;
    semop(semid, &sb, 1);
}
// 生产者进程
void producer(int shmid, int semid) {
    // 附加共享内存到当前进程地址空间
    char *shm_addr = (char*)shmat(shmid, NULL, 0);
    if (shm_addr == (char*)-1) {
        perror("生产者：共享内存附加失败");
        exit(EXIT_FAILURE);
    }

    srand(time(NULL) ^ getpid()); // 初始化随机数生成器

    for (int i = 0; i < 10; i++) { // 生产10个数据
        // 生成随机数据
        char data[BLOCK_SIZE];
        snprintf(data, BLOCK_SIZE, "数据-%d（生产者PID：%d）", i, getpid());

        // P(EMPTY)：申请空块
        sem_op(semid, SEM_EMPTY, -1);
        // P(MUTEX)：获取互斥锁
        sem_op(semid, SEM_MUTEX, -1);

        // 查找第一个空块并写入数据
        int block_idx = -1;
        for (int j = 0; j < BLOCK_COUNT; j++) {
            char *block = shm_addr + j * BLOCK_SIZE;
            // 检查块是否为空（以第一个字符为标记）
            if (block[0] == '\0') {
                block_idx = j;
                strcpy(block, data);
                printf("生产者：写入块 %d -> %s\n", block_idx, data);
                break;
            }
        }

        // V(MUTEX)：释放互斥锁
        sem_op(semid, SEM_MUTEX, 1);
        // V(FULL)：增加满块计数
        sem_op(semid, SEM_FULL, 1);

        // 随机休眠一段时间，模拟生产耗时
        sleep(rand() % 2 + 1);
    }

    // 分离共享内存
    shmdt(shm_addr);
    printf("生产者：完成生产，退出\n");
}
// 消费者进程
void consumer(int shmid, int semid) {
    // 附加共享内存到当前进程地址空间
    char *shm_addr = (char*)shmat(shmid, NULL, 0);
    if (shm_addr == (char*)-1) {
        perror("消费者：共享内存附加失败");
        exit(EXIT_FAILURE);
    }
    srand(time(NULL) ^ getpid()); // 初始化随机数生成器
    for (int i = 0; i < 10; i++) { // 消费10个数据
        // P(FULL)：申请满块
        sem_op(semid, SEM_FULL, -1);
        // P(MUTEX)：获取互斥锁
        sem_op(semid, SEM_MUTEX, -1);
        // 查找第一个满块并读取数据
        int block_idx = -1;
        char data[BLOCK_SIZE];
        for (int j = 0; j < BLOCK_COUNT; j++) {
            char *block = shm_addr + j * BLOCK_SIZE;
            // 检查块是否为满（以第一个字符为标记）
            if (block[0] != '\0') {
                block_idx = j;
                strcpy(data, block);
                // 清空块，标记为可用
                block[0] = '\0';
                printf("消费者：读取块 %d -> %s\n", block_idx, data);
                break;
            }
        }
        // V(MUTEX)：释放互斥锁
        sem_op(semid, SEM_MUTEX, 1);
        // V(EMPTY)：增加空块计数
        sem_op(semid, SEM_EMPTY, 1);

        // 随机休眠一段时间，模拟消费耗时
        sleep(rand() % 2 + 1);
    }
    // 分离共享内存
    shmdt(shm_addr);
    printf("消费者：完成消费，退出\n");
}
int main() {
    // 生成唯一键值
    key_t key = ftok("/tmp", 'P');
    if (key == -1) {
        perror("ftok失败");
        exit(EXIT_FAILURE);
    }
    // 创建共享内存
    int shmid = shmget(key, SHM_SIZE, 0666 | IPC_CREAT);
    if (shmid == -1) {
        perror("共享内存创建失败");
        exit(EXIT_FAILURE);
    }
    // 初始化共享内存（全部置为空）
    char *shm_addr = (char*)shmat(shmid, NULL, 0);
    if (shm_addr == (char*)-1) {
        perror("共享内存附加失败");
        exit(EXIT_FAILURE);
    }
    memset(shm_addr, 0, SHM_SIZE); // 初始化为空块（第一个字符为'\0'）
    shmdt(shm_addr);
    // 创建信号量集
    int semid = semget(key, SEM_COUNT, 0666 | IPC_CREAT);
    if (semid == -1) {
        perror("信号量创建失败");
        shmctl(shmid, IPC_RMID, NULL); // 清理共享内存
        exit(EXIT_FAILURE);
    }
    // 初始化信号量
    semctl(semid, SEM_EMPTY, SETVAL, BLOCK_COUNT); // 空块数初始为总块数
    semctl(semid, SEM_FULL, SETVAL, 0);            // 满块数初始为0
    semctl(semid, SEM_MUTEX, SETVAL, 1);           // 互斥锁初始为1（可用）
    // 创建生产者子进程
    pid_t prod_pid = fork();
    if (prod_pid == -1) {
        perror("fork生产者失败");
        semctl(semid, 0, IPC_RMID);
        shmctl(shmid, IPC_RMID, NULL);
        exit(EXIT_FAILURE);
    } else if (prod_pid == 0) {
        producer(shmid, semid);
        exit(EXIT_SUCCESS);
    }
    // 创建消费者子进程
    pid_t cons_pid = fork();
    if (cons_pid == -1) {
        perror("fork消费者失败");
        semctl(semid, 0, IPC_RMID);
        shmctl(shmid, IPC_RMID, NULL);
        waitpid(prod_pid, NULL, 0); // 清理已创建的子进程
        exit(EXIT_FAILURE);
    } else if (cons_pid == 0) {
        consumer(shmid, semid);
        exit(EXIT_SUCCESS);
    }
    // 等待子进程结束
    waitpid(prod_pid, NULL, 0);
    waitpid(cons_pid, NULL, 0);
    // 清理资源
    semctl(semid, 0, IPC_RMID);    // 删除信号量集
    shmctl(shmid, IPC_RMID, NULL); // 删除共享内存
    printf("主进程：清理资源完成，退出\n");

    return 0;
}

```

TODO

## 4.信号

## 5.信号量

## 6.消息队列

## 7.套接字

## 8.内存映射机制
